import locale

import plotly.graph_objects as go
from matplotlib import pyplot as plt
from plotly.subplots import make_subplots

from reho.model.sub_problem import *
from reho.plotting import sankey
from reho.plotting.utils import *

__doc__ = """
Contains ready-to-use representations for results generated by REHO.
"""


def plot_performance(results, plot='costs', indexed_on='Scn_ID', label='EN_long', add_annotation=True, per_m2=False, additional_costs=None, additional_gwp=None,
                     scc=0.177, title=None, filename=None, export_format='html', scaling_factor=1, return_df=False):
    """
    Plots performance based on REHO results.

    Parameters
    ----------
    results: dict
        Dictionary of REHO results.
    plot: str
        Choose among those three possibilities:

        - 'costs' for the economic performance indicators,
        - 'gwp' for the global warming potential indicators,
        - 'combined' for a combination of the two indicators, where the emissions are converted into costs using the ``scc`` parameter.
    indexed_on: str
        Whether the results should be grouped on *Scn_ID* or *Pareto_ID*.
    label: str
        Indicates the language to use for the plot. Choose among 'FR_long', 'FR_short', 'EN_long', 'EN_short'.
    add_annotation: bool
        Adds the numerical values along the bar plots.
    per_m2: bool
        Set to True to obtain the results divided by the total ERA.
    additional_costs: dict
        Additional costs to include (choose between 'isolation', 'mobility', and 'ict') and scaling values.
    additional_gwp: dict
        Additional gwp to include (choose between 'isolation', 'mobility', and 'ict') and scaling values.
    scc: float
        Carbon externalities, expressed in *CHF/kgCO2*. Default value is the *Social Cost of Carbon*, from `Rennert, 2022 <https://www.nature.com/articles/s41586-022-05224-9>`_.
    title: str
        Title for the plot.
    filename: str
        Name of the file to be saved.
    export_format: str
        Can be either 'html', 'png', or 'pdf'.
    scaling_factor: int/float
        Scales linearly the REHO results for the plot.
    return_df: bool
        A dataframe can be returned for further post-processing or reporting purposes.

    Returns
    ----------
    plotly.graph_objs.Figure
        The generated plotly figure.
    pd.DataFrame
        (Optional) A dataframe for further post-processing or reporting purposes.
    """

    if additional_gwp is None:
        additional_gwp = {}
    if additional_costs is None:
        additional_costs = {}

    sc = list(results.keys())[0]
    id = list(results[sc].keys())[0]
    era = results[sc][id]['df_Buildings'].ERA.sum()

    df_Economics = dict_to_df(results, 'df_Economics')

    change_data = pd.DataFrame()
    change_data.index = ['x_axis_1', 'x_axis_2', 'y_axis', 'keyword', 'total', 'unites', 'scc_legend']
    decimal = 0
    lang = re.split('_', label)[0]

    if plot == 'costs':
        change_data['FR'] = ['CAPEX', 'OPEX', 'Coûts [CHF/an]', 'Coûts', 'TOTEX', ' CHF', '']
        change_data['EN'] = ['CAPEX', 'OPEX', 'Costs [CHF/y]', 'Costs', 'TOTEX', ' CHF', '']
        df_costs = df_Economics.xs('costs', level='Perf_type')
        if per_m2:
            df_costs = df_costs / era
            change_data.loc['y_axis']['FR'] = "Coûts [CHF/m2/an]"
            change_data.loc['y_axis']['EN'] = "Costs [CHF/m2/y]"
            decimal = 1
        indexes, data_capacities, data_resources = prepare_dfs(df_costs, indexed_on, neg=True, additional_data=additional_costs, scaling_factor=scaling_factor)

        data_resources = data_resources.drop("avoided", level='type')

        data_scc_resources = pd.DataFrame(0, columns=[indexes], index=data_resources.index)
        data_scc_capacities = pd.DataFrame(0, columns=[indexes], index=data_capacities.index)

        showlegend = False

    elif plot == 'gwp':
        change_data['FR'] = ['Capacités', 'Ressources', 'Émissions [kgCO2/an]', 'Émissions', 'Total', ' kgCO2', '']
        change_data['EN'] = ['Capacities', 'Resources', 'Emissions [kgCO2/y]', 'Emissions', 'Total', ' kgCO2', '']
        df_impact = df_Economics.xs('impact', level='Perf_type')
        if per_m2:
            df_impact = df_impact / era
            change_data.loc['y_axis']['FR'] = "Émissions [kgCO2/m2/an]"
            change_data.loc['y_axis']['EN'] = "Emissions [kgCO2/m2/y]"
            decimal = 1
        indexes, data_capacities, data_resources = prepare_dfs(df_impact, indexed_on, neg=True, additional_data=additional_gwp, scaling_factor=scaling_factor)

        data_resources = data_resources.drop("avoided", level='type')

        data_scc_resources = pd.DataFrame(0, columns=[indexes], index=data_resources.index)
        data_scc_capacities = pd.DataFrame(0, columns=[indexes], index=data_capacities.index)

        showlegend = False

    elif plot == 'combined':
        change_data['FR'] = ['Capacités', 'Ressources', 'Coûts [CHF/an]', 'Coûts', 'TOTEX', ' CHF', 'Impact carbone']
        change_data['EN'] = ['Capacities', 'Resources', 'Costs [CHF/y]', 'Costs', 'TOTEX', ' CHF', 'Carbon impact']

        df_costs = df_Economics.xs('costs', level='Perf_type')
        df_impact = df_Economics.xs('impact', level='Perf_type')
        if per_m2:
            df_costs = df_costs / era
            df_impact = df_impact / era
            change_data.loc['y_axis']['FR'] = "Coûts [CHF/m2/an]"
            change_data.loc['y_axis']['EN'] = "Costs [CHF/m2/y]"
            decimal = 1
        indexes, data_capacities, data_resources = prepare_dfs(df_costs, indexed_on, neg=True,
                                                               additional_data=additional_costs,
                                                               scaling_factor=scaling_factor)
        indexes, data_scc_capacities, data_scc_resources = prepare_dfs(df_impact, indexed_on, neg=True,
                                                                       additional_data=additional_gwp,
                                                                       scaling_factor=scaling_factor)

        data_resources = data_resources.drop("avoided", level='type')
        data_scc_resources = data_scc_resources.drop("avoided", level='type')

        data_scc_resources[indexes] = data_scc_resources[indexes] * scc
        data_scc_capacities[indexes] = data_scc_capacities[indexes] * scc

        showlegend = True

    sum_resources = data_resources[indexes].sum(axis=0).reset_index(drop=True)
    sum_capacities = data_capacities[indexes].sum(axis=0).reset_index(drop=True)
    sum_scc_resources = data_scc_resources[indexes].sum(axis=0).reset_index(drop=True)
    sum_scc_capacities = data_scc_capacities[indexes].sum(axis=0).reset_index(drop=True)
    combined_resources = sum_resources + sum_scc_resources
    combined_capacities = sum_capacities + sum_scc_capacities

    x1 = list(range(len(indexes)))
    x2 = [x + 1 / 3 for x in x1]
    xtick = [x + 1 / 6 for x in x1]

    text_capacities = ["<b>" + change_data.loc['x_axis_1', lang] + "</b><br>" + str(custom_round(cp, decimal))
                       for cp in combined_capacities]
    text_resources = ["<b>" + change_data.loc['x_axis_2', lang] + "</b><br>" + str(custom_round(op, decimal))
                      for op in combined_resources]
    pos_resources = data_resources[indexes][data_resources[indexes] > 0].sum(axis=0).astype(int).reset_index(drop=True) + data_scc_resources[indexes][
        data_scc_resources[indexes] > 0].sum(axis=0).astype(int).reset_index(drop=True)

    fig = go.Figure()
    neg_resources = combined_resources - pos_resources
    text_placeholder = 0.04 * max(max(combined_capacities - neg_resources + combined_resources),
                                  max(combined_capacities + combined_resources + neg_resources),
                                  max(combined_resources))

    if add_annotation:
        for i in range(len(indexes)):
            fig.add_annotation(x=x2[i], y=-text_placeholder,
                               text=text_resources[i], font=dict(size=10),
                               textangle=0, align='center', valign='top',
                               showarrow=False)
            fig.add_annotation(x=x1[i], y=-text_placeholder,
                               text=text_capacities[i], font=dict(size=10),
                               textangle=0, align='center', valign='top',
                               showarrow=False
                               )
            fig.add_annotation(x=xtick[i], y=max(combined_capacities[i], pos_resources[i],
                                                 combined_capacities[i] + combined_resources[i]) + text_placeholder,
                               text="<b>Total</b><br>" + str(custom_round((combined_capacities[i] + combined_resources[i]), decimal)) + change_data.loc['unites', lang],
                               font=dict(size=10, color=cm['darkblue']),
                               textangle=0, align='center', valign='top',
                               showarrow=False
                               )
    for line, tech in data_capacities.iterrows():
        if tech.loc[indexes].sum() > 0:
            fig.add_trace(
                go.Bar(name=tech[label],
                       x=x1,
                       y=tech[indexes],
                       marker_color=tech["ColorPastel"],
                       width=1 / 3,
                       hovertemplate=f'<b>{tech[label]}</b><br>{change_data.loc["keyword", lang]}: %{{y:.{decimal}f}}{change_data.loc["unites", lang]}',
                       legendgroup='group1',
                       legendgrouptitle_text=change_data.loc['x_axis_1', lang],
                       showlegend=True)
            )
        if data_scc_capacities.loc[line, indexes].sum() > 0:
            fig.add_trace(
                go.Bar(name='Impact - ' + data_scc_capacities.loc[line, label],
                       x=x1,
                       y=data_scc_capacities.loc[line, indexes],
                       marker_color=tech["ColorPastel"],
                       marker_pattern_shape="x",
                       width=1 / 3,
                       hovertemplate=f'<b>{tech[label]}</b><br>{change_data.loc["keyword", lang]}: %{{y:.{decimal}f}}{change_data.loc["unites", lang]}',
                       legendgroup='group1',
                       showlegend=False)
            )
    for line, layer in data_resources.iterrows():
        if abs(layer.loc[indexes].sum()) > 0:
            fig.add_trace(
                go.Bar(name=layer[label],
                       x=x2,
                       y=layer[indexes],
                       marker_color=layer["ColorPastel"],
                       width=1 / 3,
                       hovertemplate=f'<b>{layer[label]}</b><br>{change_data.loc["keyword", lang]}: %{{y:.{decimal}f}}{change_data.loc["unites", lang]}',
                       legendgroup='group2',
                       legendgrouptitle_text=change_data.loc['x_axis_2', lang],
                       showlegend=True)
            )
        if abs(data_scc_resources.loc[line, indexes].sum()) > 0:
            fig.add_trace(
                go.Bar(name='Impact - ' + data_scc_resources.loc[line, label],
                       x=x2,
                       y=data_scc_resources.loc[line, indexes],
                       marker_color=layer["ColorPastel"],
                       marker_pattern_shape="x",
                       width=1 / 3,
                       hovertemplate=f'<b>{layer[label]}</b><br>{change_data.loc["keyword", lang]}: %{{y:.{decimal}f}}{change_data.loc["unites", lang]}',
                       legendgroup='group2',
                       showlegend=False)
            )

    fig.add_trace(
        go.Bar(
            name=change_data.loc['total', lang],
            x=xtick,
            y=sum_capacities + sum_resources,
            marker_color=cm['lightblue'],
            width=1 / 6,
            hovertemplate=f'<b>Total</b><br>%{{y:.{decimal}f}}{change_data.loc["unites", lang]}',
            legendgroup='group3',
            legendgrouptitle_text='Total',
            showlegend=showlegend)
    )

    fig.add_trace(
        go.Bar(
            name=change_data.loc['scc_legend', lang],
            x=xtick,
            y=sum_scc_capacities + sum_scc_resources,
            marker_color=cm['lightblue'],
            marker_pattern_shape="x",
            width=1 / 6,
            hovertemplate=f'<b>Total</b><br>%{{y:.{decimal}f}}{change_data.loc["unites", lang]}',
            legendgroup='group3',
            legendgrouptitle_text='Total',
            showlegend=showlegend)
    )

    fig.update_layout(barmode="relative",
                      bargap=0,
                      template='plotly_white',
                      margin=dict(l=50, r=50, t=50, b=50),
                      xaxis=dict(
                          tickmode='array',
                          tickvals=xtick,
                          ticktext=indexes),
                      yaxis=dict(title=change_data.loc['y_axis', lang])
                      )

    if title is not None:
        fig.update_layout(title=title)

    if filename is not None:
        if not os.path.isdir(os.path.dirname(filename)):
            os.makedirs(os.path.dirname(filename))
        if export_format == 'html':
            fig.write_html(filename + '.' + export_format)
        if export_format == 'png' or export_format == 'pdf':
            fig.write_image(filename + '.' + export_format)

    if return_df:
        return fig, pd.concat([data_capacities, data_resources])
    else:
        return fig


def plot_expenses(results, plot='costs', indexed_on='Scn_ID', label='EN_long', premium_version=None, per_m2=False, additional_costs={}, additional_gwp={},
                  scc=0.177,
                  title=None, filename=None, export_format='html', scaling_factor=1, return_df=False):
    """
    Plots expenses based on REHO results.

    Parameters
    ----------
    results: dict
        Dictionary of REHO results.
    plot: str
        Choose among those three possibilities:

        - 'costs' for the economic performance indicators,
        - 'gwp' for the global warming potential indicators,
        - 'combined' for a combination of the two indicators, where the emissions are converted into costs using the ``scc`` parameter.
    indexed_on: str
        Whether the results should be grouped on *Scn_ID* or *Pareto_ID*.
    label: str
        Indicates the language to use for the plot. Choose among 'FR_long', 'FR_short', 'EN_long', 'EN_short'.
    premium_version : list
        If enabled, it should be an array containing the retail price and feed-in price of electricity.
    per_m2: bool
        Set to True to obtain the results divided by the total ERA.
    additional_costs: dict
        Additional costs to include (choose between 'isolation', 'mobility', and 'ict') and scaling values.
    additional_gwp: dict
        Additional gwp to include (choose between 'isolation', 'mobility', and 'ict') and scaling values.
    scc: float
        Carbon externalities, expressed in *CHF/kgCO2*. Default value is the *Social Cost of Carbon*, from `Rennert, 2022 <https://www.nature.com/articles/s41586-022-05224-9>`_.
    title: str
        Title for the plot.
    filename: str
        Name of the file to be saved.
    export_format: str
        Can be either 'html', 'png', or 'pdf'.
    scaling_factor: int/float
        Scales linearly the REHO results for the plot.
    return_df: bool
        A dataframe can be returned for further post-processing or reporting purposes.

    Returns
    ----------
    plotly.graph_objs.Figure
        The generated plotly figure.
    pd.DataFrame
        (Optional) A dataframe for further post-processing or reporting purposes.
    """

    sc = list(results.keys())[0]
    id = list(results[sc].keys())[0]
    era = results[sc][id]['df_Buildings'].ERA.sum()

    df_Economics = dict_to_df(results, 'df_Economics')

    change_data = pd.DataFrame()
    change_data.index = ['x_axis_1', 'x_axis_2', 'y_axis', 'keyword', 'total', 'unites', 'leg_1', 'leg_2', 'scc_legend']
    decimal = 0
    lang = re.split('_', label)[0]

    if plot == 'costs':
        change_data['FR'] = ['Coûts', 'Revenus', '[CHF/an]', 'Coûts', 'Total', ' CHF', 'Capacités', 'Ressources', '']
        change_data['EN'] = ['Costs', 'Revenues', '[CHF/y]', 'Costs', 'Total', ' CHF', 'Capacities', 'Resources', '']
        df_costs = df_Economics.xs('costs', level='Perf_type')
        if per_m2:
            df_costs = df_costs / era
            change_data.loc['y_axis']['FR'] = "Coûts [CHF/m2/an]"
            change_data.loc['y_axis']['EN'] = "Costs [CHF/m2/y]"
            decimal = 1
        indexes, data_capacities, data_resources = prepare_dfs(df_costs, indexed_on, neg=False,
                                                               premium_version=premium_version, additional_data=additional_costs, scaling_factor=scaling_factor)

        data_scc_resources = pd.DataFrame(0, columns=[indexes], index=data_resources.index)
        data_scc_capacities = pd.DataFrame(0, columns=[indexes], index=data_capacities.index)

    elif plot == 'gwp':
        change_data['FR'] = ['Émissions', 'Évitées', 'Émissions [kgCO2/an]', 'Émissions', 'Total', ' kgCO2', 'Capacités', 'Ressources', '']
        change_data['EN'] = ['Emissions', 'Avoided', 'Emissions [kgCO2/y]', 'Emissions', 'Total', ' kgCO2', 'Capacities', 'Resources', '']
        df_impact = df_Economics.xs('impact', level='Perf_type')
        if per_m2:
            df_impact = df_impact / era
            change_data.loc['y_axis']['FR'] = "Émissions [kgCO2/m2/an]"
            change_data.loc['y_axis']['EN'] = "Emissions [kgCO2/m2/y]"
            decimal = 1
        indexes, data_capacities, data_resources = prepare_dfs(df_impact, indexed_on, neg=False,
                                                               premium_version=premium_version, additional_data=additional_gwp, scaling_factor=scaling_factor)

        data_scc_resources = pd.DataFrame(0, columns=[indexes], index=data_resources.index)
        data_scc_capacities = pd.DataFrame(0, columns=[indexes], index=data_capacities.index)

    elif plot == 'combined':
        change_data['FR'] = ['Coûts', 'Revenus', 'Coûts [CHF/an]', 'Coûts', 'Total', ' CHF', 'Capacités', 'Ressources', 'Impact carbone']
        change_data['EN'] = ['Costs', 'Revenues', 'Costs [CHF/y]', 'Costs', 'Total', ' CHF', 'Capacities', 'Resources', 'Carbon impact']

        df_costs = df_Economics.xs('costs', level='Perf_type')
        df_impact = df_Economics.xs('impact', level='Perf_type')
        if per_m2:
            df_costs = df_costs / era
            df_impact = df_impact / era
            change_data.loc['y_axis']['FR'] = "Coûts [CHF/m2/an]"
            change_data.loc['y_axis']['EN'] = "Costs [CHF/m2/y]"
            decimal = 1
        indexes, data_capacities, data_resources = prepare_dfs(df_costs, indexed_on, neg=False,
                                                               additional_data=additional_costs,
                                                               scaling_factor=scaling_factor)
        indexes, data_scc_capacities, data_scc_resources = prepare_dfs(df_impact, indexed_on, neg=False,
                                                                       additional_data=additional_gwp,
                                                                       scaling_factor=scaling_factor)
        data_scc_resources[indexes] = data_scc_resources[indexes] * scc
        data_scc_capacities[indexes] = data_scc_capacities[indexes] * scc

    costs = pd.concat([data_capacities, data_resources.xs('costs', level='type')], keys=['investment', 'operation'], names=['Category'])
    revenues = data_resources.loc[['avoided', 'revenues'], :]
    costs = costs[costs[indexes].sum(axis=1) > 0]
    revenues = revenues[revenues[indexes].sum(axis=1) > 0]
    totex = costs[indexes].sum(axis=0) - revenues[indexes].sum(axis=0)
    revenues = revenues.reindex(columns=costs.columns.tolist())

    costs_scc = pd.concat([data_scc_capacities, data_scc_resources.xs('costs', level='type')], keys=['investment', 'operation'], names=['Category'])
    revenues_scc = data_scc_resources.loc[['avoided', 'revenues'], :]
    totex_scc = costs_scc[indexes].sum(axis=0) - revenues_scc[indexes].sum(axis=0)
    revenues_scc = revenues_scc.reindex(columns=costs_scc.columns.tolist())

    sum_costs = costs[indexes].sum(axis=0).reset_index(drop=True)
    sum_revenues = revenues[indexes].sum(axis=0).reset_index(drop=True)
    sum_scc_costs = costs_scc[indexes].sum(axis=0).reset_index(drop=True)
    sum_scc_revenues = revenues_scc[indexes].sum(axis=0).reset_index(drop=True)

    x1 = list(range(len(indexes)))
    x2 = [x + 1 / 3 for x in x1]
    xtick = [x + 1 / 6 for x in x1]
    combined_costs = sum_costs + sum_scc_costs
    combined_revenues = sum_revenues + sum_scc_revenues
    combined_totex = totex.values + totex_scc.values
    text_revenues = ["<b>" + change_data.loc['x_axis_2', lang] + "</b><br>" + str(custom_round(cp, decimal)) + change_data.loc['unites', lang]
                     for cp in combined_revenues]
    text_costs = ["<b>" + change_data.loc['x_axis_1', lang] + "</b><br>" + str(custom_round(op, decimal)) + change_data.loc['unites', lang]
                  for op in combined_costs]
    text_totex = ["<b>" + change_data.loc['total', lang] + "</b><br>" + str(custom_round(tot, decimal)) + change_data.loc['unites', lang]
                  for tot in combined_totex]

    fig = go.Figure()
    for i in range(len(indexes)):
        fig.add_annotation(x=x2[i], y=-0.04 * max(max(combined_revenues), max(combined_costs)),
                           text=text_revenues[i], font=dict(size=10),
                           textangle=0, align='center', valign='top',
                           showarrow=False)
        fig.add_annotation(x=x1[i], y=-0.04 * max(max(combined_revenues), max(combined_costs)),
                           text=text_costs[i], font=dict(size=10),
                           textangle=0, align='center', valign='top',
                           showarrow=False
                           )
        fig.add_annotation(x=xtick[i], y=combined_costs[i] + 0.04 * max(max(combined_revenues), max(combined_costs)),
                           text=text_totex[i],
                           font=dict(size=10, color=cm['darkblue']),
                           textangle=0, align='center', valign='top',
                           showarrow=False
                           )

    df_scc = costs_scc.xs('investment', level='Category')
    for line, tech in costs.xs('investment', level='Category').iterrows():
        if tech.loc[indexes].sum() > 0:
            fig.add_trace(
                go.Bar(name=tech[label],
                       x=x1,
                       y=tech[indexes],
                       marker_color=tech["ColorPastel"],
                       width=1 / 3,
                       hovertemplate=f'<b>{tech[label]}</b><br>{change_data.loc["keyword", lang]}: %{{y:.{decimal}f}}{change_data.loc["unites", lang]}',
                       legendgroup='group1',
                       legendgrouptitle_text=change_data.loc['leg_1', lang],
                       showlegend=True)
            )
        if line in df_scc.index and df_scc.loc[line, indexes].sum() > 0:
            fig.add_trace(
                go.Bar(name='Impact - ' + df_scc.loc[line, label],
                       x=x1,
                       y=df_scc.loc[line, indexes],
                       marker_color=tech["ColorPastel"],
                       marker_pattern_shape="x",
                       width=1 / 3,
                       hovertemplate=f'<b>{tech[label]}</b><br>{change_data.loc["keyword", lang]}: %{{y:.{decimal}f}}{change_data.loc["unites", lang]}',
                       legendgroup='group1',
                       showlegend=False)
            )
    df_scc = costs_scc.xs('operation', level='Category')
    for line, layer in costs.xs('operation', level='Category').iterrows():
        fig.add_trace(
            go.Bar(name=layer[label],
                   x=x1,
                   y=layer[indexes],
                   marker_color=layer["ColorPastel"],
                   width=1 / 3,
                   hovertemplate=f'<b>{layer[label]}</b><br>{change_data.loc["keyword", lang]}: %{{y:.{decimal}f}}{change_data.loc["unites", lang]}',
                   legendgroup='group2',
                   legendgrouptitle_text=change_data.loc['leg_2', lang],
                   showlegend=True)
        )
        if line in df_scc.index and df_scc.loc[line, indexes].sum() > 0:
            fig.add_trace(
                go.Bar(name='Impact - ' + df_scc.loc[line, label],
                       x=x1,
                       y=df_scc.loc[line, indexes],
                       marker_color=layer["ColorPastel"],
                       marker_pattern_shape="x",
                       width=1 / 3,
                       hovertemplate=f'<b>{layer[label]}</b><br>{change_data.loc["keyword", lang]}: %{{y:.{decimal}f}}{change_data.loc["unites", lang]}',
                       legendgroup='group1',
                       showlegend=False)
            )

    fig.add_trace(
        go.Bar(name=change_data.loc['total', lang],
               x=x2,
               y=combined_totex,
               opacity=0,
               width=1 / 6,
               showlegend=False)
    )

    df_scc = revenues_scc
    for line, layer in revenues.iterrows():
        fig.add_trace(
            go.Bar(name=layer[label],
                   x=x2,
                   y=layer[indexes],
                   marker=dict(color=layer["ColorPastel"]),
                   width=1 / 3,
                   hovertemplate=f'<b>{layer[label]}</b><br>{change_data.loc["keyword", lang]}: %{{y:.{decimal}f}}{change_data.loc["unites", lang]}',
                   legendgroup='group2',
                   legendgrouptitle_text=change_data.loc['x_axis_2', lang],
                   showlegend=True)
        )
        if line in df_scc.index and df_scc.loc[line, indexes].sum() > 0:
            fig.add_trace(
                go.Bar(name='Impact - ' + df_scc.loc[line, label],
                       x=x2,
                       y=df_scc.loc[line, indexes],
                       marker_color=layer["ColorPastel"],
                       marker_pattern_shape="x",
                       width=1 / 3,
                       hovertemplate=f'<b>{layer[label]}</b><br>{change_data.loc["keyword", lang]}: %{{y:.{decimal}f}}{change_data.loc["unites", lang]}',
                       legendgroup='group1',
                       showlegend=False)
            )

    fig.update_layout(barmode="relative",
                      bargap=0,
                      template='plotly_white',
                      margin=dict(l=50, r=50, t=50, b=50),
                      xaxis=dict(
                          tickmode='array',
                          tickvals=xtick,
                          ticktext=indexes),
                      yaxis=dict(title=change_data.loc['y_axis', lang])
                      )

    if title is not None:
        fig.update_layout(title=title)

    if filename is not None:
        if not os.path.isdir(os.path.dirname(filename)):
            os.makedirs(os.path.dirname(filename))
        if export_format == 'html':
            fig.write_html(filename + '.' + export_format)
        if export_format == 'png' or export_format == 'pdf':
            fig.write_image(filename + '.' + export_format)

    if return_df:
        return fig, pd.concat([costs, revenues])
    else:
        return fig


def plot_sankey(df_Results, label='EN_long', color='ColorPastel', title=None, filename=None, export_format='html', scaling_factor=1, return_df=False):
    """
    Plots a Sankey plot based on the results DataFrame.

    Parameters
    ----------
    df_Results: pd.DataFrame
        DataFrame coming from REHO results (already extracted from the desired *Scn_ID* and *Pareto_ID*).
    label: str
        Indicate the language to use for the plot. Choose among 'FR_long', 'FR_short', 'EN_long', 'EN_short'.
    color: str
        Indicate the color set to use for the plot. Choose among 'ColorPastel', 'ColorFlash'.
    title: str
        Title for the plot.
    filename: str
        Name of the file to be saved.
    export_format: str
        Can be either 'html', 'png', or 'pdf'.
    scaling_factor: int/float
        Scales linearly the REHO results for the plot.
    return_df: bool
        A dataframe can be returned for further post-processing or reporting purposes.

    Returns
    ----------
    plotly.graph_objs.Figure
        The generated plotly figure.
    pd.DataFrame
        (Optional) A dataframe for further post-processing or reporting purposes.
    """
    source, target, value, label_, color_ = sankey.df_sankey(df_Results, label=label, color=color, precision=2,
                                                             units='MWh', display_label_value=True,
                                                             scaling_factor=scaling_factor)

    fig = go.Figure(data=[go.Sankey(
        orientation="h",
        valueformat=".2f",
        valuesuffix=" MWh",
        node=dict(
            pad=15,
            thickness=20,
            line=dict(color="black", width=0.5),
            label=label_,
            color=color_,
        ),
        link=dict(
            source=source,
            target=target,
            value=value
        ))])

    if title is not None:
        fig.update_layout(title=title)

    if filename is not None:
        if not os.path.isdir(os.path.dirname(filename)):
            os.makedirs(os.path.dirname(filename))
        if export_format == 'html':
            fig.write_html(filename + '.' + export_format)
        if export_format == 'png' or export_format == 'pdf':
            fig.write_image(filename + '.' + export_format)

    if return_df:
        df = pd.DataFrame()
        df["source"] = [label_[int(s)].split("\n")[0] for s in source]
        df["target"] = [label_[int(t)].split("\n")[0] for t in target]
        df["Energy [MWh/yr]"] = value
        return fig, df
    else:
        return fig


def plot_profiles(df_Results, units_to_plot, style='plotly', label='EN_long', color='ColorPastel', resolution='weekly', plot_curtailment=False,
                  title=None, filename=None, export_format='html', return_df=False):
    """
    Plots an hourly profile for an entire year of operation.

    Parameters
    ----------
    df_Results: pd.DataFrame
        DataFrame coming from REHO results (already extracted from the desired *Scn_ID* or *Pareto_ID*).
    units_to_plot: list
        Units to be plotted.
    style: str
        Choose between 'plotly' or 'matplotlib'.
    label: str
        Indicate the language to use for the plot. Choose among 'FR_long', 'FR_short', 'EN_long', 'EN_short'.
    color: str
        Indicate the color set to use for the plot. Choose among 'ColorPastel', 'ColorFlash'.
    resolution: str
        Moving average possible, choose between 'monthly', 'weekly', and 'daily'.
    plot_curtailment: bool
        PV curtailment can optionally be plotted.
    title: str
        Title for the plot.
    filename: str
        Name of the file to be saved.
    export_format: str
        Can be either 'html', 'png', or 'pdf'.
    return_df: bool
        A dataframe can be returned for further post-processing or reporting purposes.

    Returns
    ----------
    plotly.graph_objs.Figure
        The generated plotly figure.
    pd.DataFrame
        (Optional) A dataframe for further post-processing or reporting purposes.
    """
    if resolution == 'monthly':
        items_average = 730
    elif resolution == 'weekly':
        items_average = 168
    elif resolution == 'daily':
        items_average = 24
    else:
        items_average = 1

    units_demand = []
    units_supply = []
    for unit in units_to_plot:
        if unit == "PV":
            units_supply.append(unit)
        elif unit in ["Battery", "EV_district"]:
            units_demand.append(unit)
            units_supply.append(unit)
        else:
            units_demand.append(unit)

    # Grids
    imports = {}
    exports = {}
    layers =  df_Results['df_Grid_t'].index.get_level_values("Layer").unique()
    for layer in layers:
        imports[layer] = df_Results['df_Grid_t'].xs((layer, 'Network'), level=('Layer', 'Hub')).Grid_supply[:-2]
        exports[layer] = df_Results['df_Grid_t'].xs((layer, 'Network'), level=('Layer', 'Hub')).Grid_demand[:-2]

    import_profile = {}
    export_profile = {}
    for layer in layers:
        import_profile[layer] = np.array([])
        export_profile[layer] = np.array([])
        for i in range(1, 366):
            id = df_Results['df_Index'].PeriodOfYear[i * 24]
            import_profile[layer] = np.concatenate((import_profile[layer], imports[layer].xs(id)))
            export_profile[layer] = np.concatenate((export_profile[layer], exports[layer].xs(id)))

        import_profile[layer] = moving_average(import_profile[layer], items_average)
        export_profile[layer] = moving_average(export_profile[layer], items_average)

    # Units
    demands = dict()
    supplies = dict()
    curtailments = dict()
    for unit in units_to_plot:
        df_aggregated = df_Results['df_Unit_t'][df_Results['df_Unit_t'].index.get_level_values('Unit').str.contains(unit)]
        if unit in units_demand:
            demand = df_aggregated.droplevel('Layer').Units_demand[:-2].groupby(['Period', 'Time']).sum()
            demands[unit] = np.array([])
            for i in range(1, 366):
                t = df_Results['df_Index'].PeriodOfYear[i * 24]
                demands[unit] = np.concatenate((demands[unit], demand.xs(t)))
        if unit in units_supply:
            supply = df_aggregated.droplevel('Layer').Units_supply[:-2].groupby(['Period', 'Time']).sum()
            supplies[unit] = np.array([])
            for i in range(1, 366):
                t = df_Results['df_Index'].PeriodOfYear[i * 24]
                supplies[unit] = np.concatenate((supplies[unit], supply.xs(t)))
        if unit == 'PV' and plot_curtailment:
            curtailment = df_aggregated.droplevel('Layer').Units_curtailment[:-2].groupby(['Period', 'Time']).sum()
            curtailments[unit] = np.array([])
            for i in range(1, 366):
                t = df_Results['df_Index'].PeriodOfYear[i * 24]
                curtailments[unit] = np.concatenate((curtailments[unit], curtailment.xs(t)))

    for unit in units_demand:
        demands[unit] = moving_average(demands[unit], items_average)
    for unit in units_supply:
        supplies[unit] = moving_average(supplies[unit], items_average)
    if plot_curtailment:
        curtailments['PV'] = moving_average(curtailments['PV'], items_average)

    idx = list(range(1, len(import_profile["Electricity"]) + 1))

    obj_x = 'Time [hours]'
    obj_y = '[kWh]'

    if style == 'matplotlib':
        fig, ax = plt.subplots()
        ax.plot(idx, import_profile["Electricity"], color=layout.loc['Electrical_grid', color],
                label=layout.loc['Electrical_grid', label])
        ax.plot(idx, -export_profile["Electricity"], color=layout.loc['Electrical_grid_feed_in', color],
                label=layout.loc['Electrical_grid_feed_in', label])
        for layer in list(layers)[1:]:
            ax.plot(idx, import_profile[layer], color=layout.loc[layer, color], label=layout.loc[layer, label], alpha=0.5)
        for unit in units_demand:
            ax.plot(idx, demands[unit], linestyle='--', label=layout.loc[unit, label], color=layout.loc[unit, color])
        for unit in units_supply:
            ax.plot(idx, -supplies[unit], label=layout.loc[unit, label], color=layout.loc[unit, color])
        if plot_curtailment:
            ax.plot(idx, -curtailments['PV'], linestyle='.', label=layout.loc['Curtailment', label],
                    color=layout.loc['Curtailment', color])

        ax.set_title(title)
        ax.set_xlabel(obj_x)
        ax.set_ylabel(obj_y)
        ax.legend(loc='best')

        if filename is not None:
            if not os.path.isdir(os.path.dirname(filename)):
                os.makedirs(os.path.dirname(filename))
            if export_format == 'png' or export_format == 'pdf':
                plt.tight_layout()
                plt.savefig((filename + '.' + export_format), format=export_format, dpi=300)

        return plt

    else:
        fig = go.Figure()

        fig.add_trace(go.Scatter(
            x=idx,
            y=import_profile["Electricity"],
            mode="lines",
            name=layout.loc['Electrical_grid', label],
            line=dict(color=layout.loc['Electrical_grid', color])
        ))

        if export_profile["Electricity"].any() > 0:
            fig.add_trace(go.Scatter(
                x=idx,
                y=-export_profile["Electricity"],
                mode="lines",
                name=layout.loc['Electrical_grid_feed_in', label],
                line=dict(color=layout.loc['Electrical_grid_feed_in', color], dash='dash')
            ))

        for layer in list(layers)[1:]:
            if import_profile[layer].any() > 0:
                fig.add_trace(go.Scatter(
                    x=idx,
                    y=import_profile[layer],
                    mode="lines",
                    name=layout.loc[layer, label],
                    line=dict(color=layout.loc[layer, color])
                ))

        for unit in units_demand:
            if demands[unit].any() > 0:
                fig.add_trace(go.Scatter(
                    x=idx,
                    y=demands[unit],
                    mode="lines",
                    name=layout.loc[unit, label],
                    line=dict(color=layout.loc[unit, color])
                ))
        for unit in units_supply:
            if supplies[unit].any() > 0:
                fig.add_trace(go.Scatter(
                    x=idx,
                    y=-supplies[unit],
                    mode="lines",
                    name=layout.loc[unit, label],
                    line=dict(color=layout.loc[unit, color], dash='dash')
                ))
        if plot_curtailment:
            fig.add_trace(go.Scatter(
                x=idx,
                y=-curtailments['PV'],
                mode="lines",
                name=layout.loc['Curtailment', label],
                line=dict(color=layout.loc['Curtailment', color], dash='dot')
            ))

        fig.update_layout(
            xaxis_title=obj_x,
            yaxis_title=obj_y
        )

        if title is not None:
            fig.update_layout(title=title)

        if filename is not None:
            if not os.path.isdir(os.path.dirname(filename)):
                os.makedirs(os.path.dirname(filename))
            if export_format == 'html':
                fig.write_html(filename + '.' + export_format)
            if export_format == 'png' or export_format == 'pdf':
                fig.write_image(filename + '.' + export_format)

        if return_df:
            return fig, pd.DataFrame()
        else:
            return fig


def plot_eud(results, label='EN_long', title=None, filename=None, export_format='html', scaling_factor=1, return_df=False):
    """
    Plots a Sunburst for End Use Demand (EUD) based on REHO results, grouped by buildings' class.

    Parameters
    ----------
    results: dict
        Dictionary of REHO results.
    label: str
        Indicate the language to use for the plot. Choose among 'FR_long', 'FR_short', 'EN_long', 'EN_short'.
    title: str
        Title for the plot.
    filename: str
        Name of the file to be saved.
    export_format: str
        Can be either 'html', 'png', or 'pdf'.
    scaling_factor: int/float
        Scales linearly the REHO results for the plot.
    return_df: bool
        A dataframe can be returned for further post-processing or reporting purposes.

    Returns
    ----------
    plotly.graph_objs.Figure
        The generated plotly figure.
    pd.DataFrame
        (Optional) A dataframe for further post-processing or reporting purposes.
    """

    def add_class(row):
        ratio = [float(s) for s in str(row['ratio']).split("/")]
        class_ = row['id_class'].split("/")
        serie = pd.Series(ratio, index=class_).groupby(level=0).sum()
        for key, value in correspondance_dict.items():
            data_to_plot[value].update(data_to_plot[value] + serie * row[key])

    correspondance_dict = {'ERA': 'area_per_class',
                           'SH': 'sh_per_class',
                           'DHW': 'dhw_per_class',
                           'Electricity': 'elec_per_class'}
    classes = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII']
    df_buildings = dict_to_df(results, 'df_Buildings')
    df_annuals = dict_to_df(results, 'df_Annuals').reset_index().pivot(index=['Scn_ID', 'Pareto_ID', 'Hub'],
                                                                       columns='Layer', values='Demand_MWh')
    df_buildings = df_buildings.reset_index().merge(df_annuals, on=['Scn_ID', 'Pareto_ID', 'Hub']).set_index(
        ['Scn_ID', 'Pareto_ID', 'Hub'])
    data_to_plot = pd.DataFrame(0, index=classes, columns=['area_per_class', 'sh_per_class', 'dhw_per_class',
                                                           'elec_per_class'])
    class_names = pd.read_csv(os.path.join(path_to_plotting, 'sia380_1.csv'), index_col='id_class', sep=";")
    data_to_plot = data_to_plot.merge(class_names, left_index=True, right_on='id_class')

    if 'FR' in label.upper().split("_"):
        hover_text = 'Demande en énergie'
        liaison = ' du '
    else:
        hover_text = 'End Use Demand'
        liaison = ' of '

    scenarios = list(results.keys())
    paretos = list(results[scenarios[0]].keys())

    df_buildings.loc[(scenarios[0], paretos[0])].apply(add_class, axis=1)
    child_name = []
    parents_name = []
    text_template = []
    hover_template = []
    values_sun = []
    for i in range(len(classes)):
        [child_name.append(element) for element in [data_to_plot.iloc[i]['class_' + label], "SH", "DHW", "Elec"]]
        [parents_name.append(element) for element in
         ["Total", data_to_plot.iloc[i]['class_' + label], data_to_plot.iloc[i]['class_' + label],
          data_to_plot.iloc[i]['class_' + label]]]
        [values_sun.append(element) for element in [
            data_to_plot.iloc[i]['sh_per_class'] + data_to_plot.iloc[i]['dhw_per_class'] +
            data_to_plot.iloc[i]['elec_per_class'],
            data_to_plot.iloc[i]['sh_per_class'], data_to_plot.iloc[i]['dhw_per_class'],
            data_to_plot.iloc[i]['elec_per_class']]]
        [text_template.append(element) for element in ['%{label}<br>%{percentParent:.2%}',
                                                       '%{label}<br>%{percentParent:.2%}',
                                                       '%{label}<br>%{percentParent:.2%}',
                                                       '%{label}<br>%{percentParent:.2%}']]
        [hover_template.append(element) for element in
         ['<i>%{label}</i><br><b>' + hover_text + ': </b>%{value} MWh<br>%{percentParent:.2%}' + liaison + '%{parent}',
          '<i>%{label}</i><br><b>' + hover_text + ': </b>%{value} MWh<br>%{percentRoot:.2%}' + liaison + '%{root}',
          '<i>%{label}</i><br><b>' + hover_text + ': </b>%{value} MWh<br>%{percentRoot:.2%}' + liaison + '%{root}',
          '<i>%{label}</i><br><b>' + hover_text + ': </b>%{value} MWh<br>%{percentRoot:.2%}' + liaison + '%{root}']]

    values_sun = [round(val * scaling_factor, 2) for val in values_sun]
    fig = go.Figure(go.Sunburst(
        labels=child_name,
        parents=parents_name,
        values=values_sun,
        branchvalues='total',
        name=hover_text,
        hovertemplate=hover_template,
        texttemplate=text_template,
    ))

    fig.update_layout(
        sunburstcolorway=["#413D3A", "#CAC7C7", "#B51F1F", "#007480", "#00A79F", "#FEA993"],
        extendsunburstcolors=True)

    if title is not None:
        fig.update_layout(title=title)

    if filename is not None:
        if not os.path.isdir(os.path.dirname(filename)):
            os.makedirs(os.path.dirname(filename))
        if export_format == 'html':
            fig.write_html(filename + '.' + export_format)
        if export_format == 'png' or export_format == 'pdf':
            fig.write_image(filename + '.' + export_format)

    if return_df:
        df = pd.DataFrame()
        df["Energy Use"] = child_name
        df["Building Type"] = parents_name
        df["Energy Demand"] = values_sun
        return fig, df

    return fig


def plot_unit_monthly(results, unit_to_plot, label='EN_short', title=None, filename=None, export_format='html'):
    """
    Generates a monthly bar plot showing the mean energy produced per hour and the installed power for a specific unit.

    Parameters
    ----------
    results: dict
        Dictionary of REHO results.
    unit_to_plot: dict
        Specify the unit to plot and Scn_ID / Pareto_ID from which it should be found.
    label: str
        Indicates the language to use for the plot. Choose among 'FR_long', 'FR_short', 'EN_long', 'EN_short'.
    title: str
        Title for the plot.
    filename: str
        Name of the file to be saved.
    export_format: str
        Can be either 'html', 'png', or 'pdf'.

    Returns
    ----------
    plotly.graph_objs.Figure
        The generated plotly figure.
    pd.DataFrame
        (Optional) A dataframe for further post-processing or reporting purposes.

    Examples
    --------
    >>> reho_results = pd.read_pickle('results/progressive_scenario.pickle')
    >>> unit_to_plot = {'Unit': 'NG_Boiler', 'Scn_ID': 'fossil', 'Pareto_ID': False}
    >>> plot_unit_monthly(reho_results, unit_to_plot, label='FR_long', filename="my_plot", export_format='png').show()

    """

    def monthly_average_balance(results, unit_to_plot):
        """
        Return data to plot a monthly heat balance.

        :return: pd.Series of House_Q_heating, -House_Q_cooling, House_Q_convection, HeatGains, SolarGains

        """

        df_Unit_t_t = remove_building_from_index(results['df_Unit_t'])
        pos_units = df_Unit_t_t.index.get_level_values('Unit').unique()
        pos_columns_bui = ['House_Q_heating', 'House_Q_cooling', 'House_Q_convection', 'HeatGains', 'SolarGains']

        df_period_time = df_Unit_t_t.index.to_frame()[['Period', 'Time']].reset_index(drop=True)

        df_type = ''
        if unit_to_plot in pos_units:
            df_type = 'unit'
        elif unit_to_plot in pos_columns_bui:
            df_type = 'building'

        # For unit
        if df_type == 'unit':
            if unit_to_plot == 'PV':
                column_to_plot = 'Units_supply'
            else:
                column_to_plot = 'Units_demand'
            df_to_extract = df_Unit_t_t.xs(unit_to_plot, level='Unit').droplevel('Layer')[column_to_plot][:-2]

        elif df_type == 'building':
            # Extract the data
            df_Weather = results['df_Weather']
            df_buildings_th_feature = results['df_Buildings'][['U_h', 'ERA']]

            if unit_to_plot == 'House_Q_convection':
                df_to_extract = pd.DataFrame(0, index=df_period_time, columns=[unit_to_plot])
                # For each building: calculation of the heat flux
                # and addition of the flux of each building in df_heat_building_t
                for b in list(df_buildings_th_feature.index):
                    df_to_extract['House_Q_convection'] = df_buildings_th_feature.loc[b, 'U_h'] * \
                                                          df_buildings_th_feature.loc[b, 'ERA'] * \
                                                          (df_Weather.T_ext - df_Weather.T_in)
                df_to_extract = df_to_extract[:-2]
            else:
                df_to_extract = results['df_Buildings_t'][unit_to_plot][:-2]
        else:
            # Case where the unit is not referenced in df_Unit_t such as for WaterTank
            if 'df_Streams_t' in results.dict_config.keys():
                df_Streams_t = remove_building_from_index(results['df_Streams_t'])
                df_to_extract = df_Streams_t.xs(unit_to_plot, level='Unit')['Streams_Q'][:-2]
            else:
                idx = pd.MultiIndex.from_frame(df_period_time)
                units_mult = remove_building_from_index(results['df_Unit']).reset_index().groupby('Unit').sum()[
                    'Units_Mult']
                df_to_extract = pd.Series(units_mult, index=idx)

        month_values = monthly_average(results, df_to_extract)

        return month_values

    design = layout.loc[unit_to_plot['Unit']]

    # Filter the right results dictionary from the REHO results dictionary
    if 'Scn_ID' not in unit_to_plot.keys() or not unit_to_plot['Scn_ID']:
        scn_id = list(results.keys())[0]
        if 'Pareto_ID' not in unit_to_plot.keys() or not unit_to_plot['Pareto_ID']:
            pareto_id = list(results[scn_id].keys())[0]
        else:
            pareto_id = unit_to_plot['Pareto_ID']
    else:
        scn_id = unit_to_plot['Scn_ID']
        pareto_id = 0
    unit_to_plot = unit_to_plot['Unit']
    df_Results = results[scn_id][pareto_id]

    month_values = monthly_average_balance(df_Results, unit_to_plot)
    sized = remove_building_from_index(df_Results['df_Unit']).loc[unit_to_plot]['Units_Mult']

    title_y = 'Energy [kWh/h]'
    power = 'Power installed [kW]'
    energy = 'Mean energy produced per hour [kWh/h]'
    title = 'Power installed and energy produced for {}'.format(design.loc[label])

    if 'FR' in label:
        locale.setlocale(locale.LC_TIME, 'fr_FR.UTF-8')
        title_y = 'Energie [kWh/h]'
        power = 'Puissance installée [kW]'
        energy = 'Energie moyenne produite par heure [kWh/h]'
        title = 'Puissance installée et énergie produite pour {}'.format(design.loc[label])
    if 'short' in label:
        month_ticks = list(calendar.month_abbr)[1:]
    else:
        month_ticks = list(calendar.month_name)[1:]

    # month_ticks = [month.encode('latin1').decode('utf-8') for month in month_ticks]

    fig = go.Figure(
        go.Bar(
            name=energy,
            x=list(range(1, 13)), y=month_values,
            width=1, showlegend=False,
            hovertemplate="<b>" + design.loc[label] + "</b><br>%{y:.0f} kWh/h",
            marker=dict(color=design.loc['ColorPastel']),
        ),
        go.Layout(
            template='plotly_white',
            bargap=0,
            xaxis=dict(
                tickmode='array',
                tickvals=list(range(1, 13)),
                ticktext=month_ticks
            ),
            yaxis=dict(title=title_y),
            title=title
        )
    )
    if sized is not None:
        max_y = sized
        fig.add_trace(
            go.Bar(
                name=power,
                x=[6.5], y=[max_y],
                width=12, showlegend=False,
                hovertemplate="<b>" + design.loc[label] + "</b><br>%{y:.0f} kW",
                marker=dict(color=design.loc['ColorPastel'], opacity=0.3),
            )
        )
        fig.update_layout(yaxis=dict(range=[0, max_y]))

    if title is not None:
        fig.update_layout(title=title)

    if filename is not None:
        if not os.path.isdir(os.path.dirname(filename)):
            os.makedirs(os.path.dirname(filename))
        if export_format == 'html':
            fig.write_html(filename + '.' + export_format)
        if export_format == 'png' or export_format == 'pdf':
            fig.write_image(filename + '.' + export_format)

    return fig


def plot_pareto(results, color='ColorPastel', title=None, return_df=False):
    """
    Plots a Pareto front based on REHO results. CAPEX, OPEX, TOTEX and GWP are displayed.

    Parameters
    ----------
    results: dict
        Dictionary of REHO results.
    color: str
        Indicate the color set to use for the plot. Choose among 'ColorPastel', 'ColorFlash'.
    title: str
        Title for the plot.
    return_df: bool
        A dataframe can be returned for further post-processing or reporting purposes.

    Returns
    ----------
    plotly.graph_objs.Figure
        The generated plotly figure.
    pd.DataFrame
        (Optional) A dataframe for further post-processing or reporting purposes.
    """

    df_performance = dict_to_df(results, 'df_Performance').loc[
        (slice(None), slice(None), 'Network'), ["Costs_op", "Costs_inv", "Costs_grid_connection", "Costs_rep", "GWP_op", "GWP_constr"]].reset_index(
        ['Scn_ID', 'Hub'])
    df_performance["CAPEX"] = df_performance["Costs_inv"] + df_performance["Costs_rep"]
    df_performance["OPEX"] = df_performance["Costs_op"] + df_performance["Costs_grid_connection"]
    df_performance["TOTEX"] = df_performance["CAPEX"] + df_performance["OPEX"]
    df_performance["GWP"] = df_performance["GWP_op"] + df_performance["GWP_constr"]

    fig = make_subplots(specs=[[{"secondary_y": True}]])

    fig.add_trace(go.Scatter(
        x=list(df_performance.index),
        y=df_performance["CAPEX"].round(2),
        marker=dict(color=layout.loc["CAPEX", color]),
        line=dict(dash='dash'),
        mode="lines+markers",
        name="CAPEX",
    ))

    fig.add_trace(go.Scatter(
        x=list(df_performance.index),
        y=df_performance["OPEX"].round(2),
        marker=dict(color=layout.loc["OPEX", color]),
        line=dict(dash='dash'),
        mode="lines+markers",
        name="OPEX",
    ))

    fig.add_trace(go.Scatter(
        x=list(df_performance.index),
        y=df_performance["TOTEX"].round(2),
        marker=dict(color=layout.loc["TOTEX", color]),
        mode="lines+markers",
        name="TOTEX",
    ))

    fig.add_trace(go.Scatter(
        x=list(df_performance.index),
        y=df_performance["GWP"].round(2),
        marker=dict(size=10, color=layout.loc["GWP", color], symbol='diamond'),
        mode="markers+text",
        name="GWP",
        text=df_performance["GWP"].round(2),
        textposition="top right",
        yaxis="y2",
    ))

    fig.update_layout(
        template='plotly_white',
        xaxis=dict(
            title="Scenario",
        ),
        yaxis=dict(
            title="Costs [CHF/yr]",
            titlefont=dict(
                color=layout.loc["TOTEX", color]
            ),
            tickfont=dict(
                color=layout.loc["TOTEX", color]
            )
        ),
        yaxis2=dict(
            title="GWP [kgCO2/yr]",
            titlefont=dict(
                color=layout.loc["GWP", color]
            ),
            tickfont=dict(
                color=layout.loc["GWP", color]
            )
        )
    )

    if title is not None:
        fig.update_layout(title=title)

    if return_df:
        df = df_performance[['CAPEX', 'OPEX', 'TOTEX', 'GWP']].round(2)
        df["Scenario"] = np.arange(1, len(df) + 1)
        return fig, df[["Scenario", 'CAPEX', 'OPEX', 'TOTEX', 'GWP']]
    else:
        return fig


def plot_pareto_by_objectives(results, objectives=["CAPEX", "OPEX"], style='plotly', annotation="TOTEX", title=None, filename=None, export_format='png'):
    """
    Plots a Pareto front based on REHO results. Only the 2 specified objectives are displayed. Results are expressed per m2.

    Parameters
    ----------
    results: dict
        Dictionary of REHO results.
    objectives: list
        Specify the two objectives among CAPEX, OPEX, TOTEX and GWP.
    style: str
        Choose between 'plotly' or 'matplotlib'.
    annotation: str
        Numerical values of the chosen KPI (CAPEX, OPEX, TOTEX or GWP) is printed.
    title: str
        Title for the plot.
    filename: str
        Name of the file to be saved.
    export_format: str
        Can be either 'html', 'png', or 'pdf'.

    Returns
    ----------
    plotly.graph_objs.Figure
        The generated plotly figure.
    """

    df_performance_dict = {}
    df_performance = dict_to_df(results, 'df_Performance').loc[
        (slice(None), slice(None), 'Network'), ["Costs_op", "Costs_inv", "Costs_grid_connection", "Costs_rep",
                                                "GWP_op", "GWP_constr"]].reset_index(['Scn_ID', 'Hub'])
    era = dict_to_df(results, 'df_Buildings').loc[(slice(None), 1, slice(None))].ERA.sum()
    df_performance["CAPEX"] = df_performance["Costs_inv"] + df_performance["Costs_rep"]
    df_performance["OPEX"] = df_performance["Costs_op"] + df_performance["Costs_grid_connection"]
    df_performance["TOTEX"] = df_performance["CAPEX"] + df_performance["OPEX"]
    df_performance["GWP"] = df_performance["GWP_op"] + df_performance["GWP_constr"]
    df_performance_dict[df_performance.loc[1, "Scn_ID"]] = df_performance[["CAPEX", "OPEX", "TOTEX", "GWP"]].sort_values(by=objectives[0]) / era

    if objectives[0] == "CAPEX":
        obj_x = "CAPEX [CHF/m$^2$yr]"
    elif objectives[0] == "TOTEX":
        obj_x = "TOTEX [CHF/m$^2$yr]"
    if objectives[1] == "OPEX":
        obj_y = "OPEX [CHF/m$^2$yr]"
    elif objectives[1] == "GWP":
        obj_y = "GWP [kgCO2/m$^2$yr]"

    if style == 'matplotlib':

        fig, ax = plt.subplots()

        for i, scenario in enumerate(list(df_performance_dict.keys())):
            ax.plot(df_performance_dict[scenario][objectives[0]], df_performance_dict[scenario][objectives[1]],
                    marker='.', linestyle='--', color=cm[list(cm.keys())[i + 3]])
            for sc_i in df_performance_dict[scenario].index:
                if annotation is not None:
                    value = format((df_performance_dict[scenario].loc[sc_i, annotation]), '.2f')
                    ax.annotate(str(sc_i) + ": " + str(value),
                                xy=(df_performance_dict[scenario].loc[sc_i, objectives[0]],
                                    df_performance_dict[scenario].loc[sc_i, objectives[1]]),
                                color=cm[list(cm.keys())[i + 3]],
                                size=10)

        plt.title(objectives[0] + "-" + objectives[1] + " Pareto")
        plt.xlabel(obj_x)
        plt.ylabel(obj_y)

        plt.legend(labels=list(df_performance_dict.keys()), loc='upper right', fancybox=True, shadow=True)

        if filename is not None:
            if not os.path.isdir(os.path.dirname(filename)):
                os.makedirs(os.path.dirname(filename))
            if export_format == 'png' or export_format == 'pdf':
                plt.tight_layout()
                plt.savefig((filename + '.' + export_format), format=export_format, dpi=300)

        return plt

    else:

        fig = go.Figure()

        for scenario in df_performance_dict.keys():
            fig.add_trace(go.Scatter(
                x=df_performance_dict[scenario][objectives[0]].round(2),
                y=df_performance_dict[scenario][objectives[1]].round(2),
                mode="lines+markers+text",
                name=scenario,
                text=df_performance_dict[scenario][annotation].round(2),
                textposition="top right"
            ))

        if objectives[0] == "CAPEX":
            obj_x = "CAPEX [CHF/m2/yr]"
        elif objectives[0] == "TOTEX":
            obj_x = "TOTEX [CHF/m2/yr]"

        if objectives[1] == "OPEX":
            obj_y = "OPEX [CHF/m2/yr]"
        elif objectives[1] == "GWP":
            obj_y = "GWP [kgCO2/m2/yr]"

        fig.update_layout(
            title_text=objectives[0] + "-" + objectives[1] + " Pareto",
            xaxis_title=obj_x,
            yaxis_title=obj_y,
            font=dict(
                size=16,
            )
        )

        if title is not None:
            fig.update_layout(title=title)

        if filename is not None:
            if not os.path.isdir(os.path.dirname(filename)):
                os.makedirs(os.path.dirname(filename))
            if export_format == 'html':
                fig.write_html(filename + '.' + export_format)
            if export_format == 'png' or export_format == 'pdf':
                fig.write_image(filename + '.' + export_format)

        return fig


def plot_composite_curve(df_Results, cluster, periods=["Yearly"], filename=None, export_format='png', return_df=False):
    """
    Plots a composite curve based on the results DataFrame.

    Parameters
    ----------
    df_Results: pd.DataFrame
        DataFrame coming from REHO results (already extracted from the desired *Scn_ID* and *Pareto_ID*).
    cluster: dict
        Define location, number of periods, and number of timesteps.
    periods: list
        Indicate the desired timeframe.
    filename: str
        Name of the file to be saved.
    export_format: str
        Can be either 'png', or 'pdf'.
    return_df: bool
        A dataframe can be returned for further post-processing or reporting purposes.

    Returns
    ----------
    matplotlib.pyplot
        The generated matplotlib figure.
    pd.DataFrame
        (Optional) A dataframe for further post-processing or reporting purposes.
    """

    # process results data
    df_heat = df_Results["df_Buildings_t"][["House_Q_heating", "House_Q_cooling", "Th_supply"]]
    df_heat_T = pd.DataFrame(np.round(df_heat['Th_supply'], 1).values, columns=["temperature"])
    df_heat_T.index = df_heat.index
    df_heat = pd.concat([df_heat, df_heat_T], axis=1)
    df_heat = df_heat.set_index("temperature", append=True)
    df_heat = df_heat.drop(columns="Th_supply")
    df_heat = df_heat.groupby(["Period", "temperature"], level=[1, 3]).sum()

    # get index typical periods
    file_ID = weather.get_cluster_file_ID(cluster)
    file_name = "index_" + file_ID + ".dat"
    thisfile = os.path.join(path_to_clustering, file_name)
    df = np.loadtxt(thisfile, skiprows=1, max_rows=8760)
    df = pd.DataFrame(df).set_index(0)

    # calculate monthly heat load profile, raw data
    t = [1, 744, 672, 744, 720, 744, 720, 744, 744, 720, 744, 720, 744]
    t = np.cumsum(t).tolist()
    monthly_profile = {}
    for i in range(len(t) - 1):
        month_time = df.loc[t[i]:t[i + 1] - 1]
        month_TP_rep = month_time.groupby(1).count() / 24
        profile = pd.concat([df_heat.xs(p) * month_TP_rep[2].xs(p) for p in month_TP_rep.index])
        profile = profile.groupby("temperature").sum()
        monthly_profile[i] = profile
    monthly_profile[12] = pd.concat([monthly_profile[i] for i in monthly_profile]).groupby("temperature").sum()

    # calculate monthly heat load profile stacked
    duration = [744, 672, 744, 720, 744, 720, 744, 744, 720, 744, 720, 744, 8760]
    month = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", "Yearly"]
    data = pd.DataFrame()
    for i in monthly_profile:
        profile = monthly_profile[i].assign(sum=monthly_profile[i].House_Q_heating.values.cumsum())
        profile.columns = ["Heat", "Cooling", "Heat_stacked"]
        profile = profile.assign(sum=profile.Cooling.values.cumsum())
        profile.columns = ["Heat", "Cooling", "Heat_stacked", "Cooling_stacked"]
        data_month = profile.Heat_stacked / duration[i] / 1000
        data[month[i]] = data_month

    for i in periods:
        fig, ax = plt.subplots(figsize=(9, 6))
        ax.plot(data[i], data[i].index, color="indianred", label="Space heating")
        plt.ylabel("Temperature [°C]", fontsize=18)
        plt.xlabel("Heat [MW]", fontsize=18)
        plt.title("Composite curve: " + i, fontsize=20)
        plt.legend(fontsize=16)
        plt.xticks(fontsize=16)
        plt.yticks(fontsize=16)
        plt.tight_layout()

    if filename is not None:
        if not os.path.isdir(os.path.dirname(filename)):
            os.makedirs(os.path.dirname(filename))
        if export_format == 'png' or export_format == 'pdf':
            plt.savefig((filename + '.' + export_format), format=export_format, dpi=300)

    if return_df:
        return plt, data.fillna(0)
    else:
        return plt



def plot_pathway(results,scn_id=None, EMOO_list=[], y_span=[],Battery_yearly=[],EV_yearly=[],y_span_yearly=[],label='EN_short', save_path="", filename=None, export_format='html', objective=None, constraint=None, district=None, scn_number=None,era=None):
    """
        Generate a line plot showing the investment pathway for the respective Objective function and EMOO selected

        :param results: Dictionary containing REHO results.
        :type results: dict

        :param label: Indicates the language to use for the plot. Pick among 'FR_long', 'FR_short', 'EN_long', 'EN_short'.
        :type label: str

        :param save_path: Path where the plot should be saved.
        :type save_path: str

        :param filename: Name of the file to be saved.
        :type filename: str

        :param export_format: Format for exporting the plot ('html' or 'png', default: 'html').
        :type export_format: str

        :return: The generated figure.
    """
    if scn_id is None:
        scn_id =  list(results.keys())[0]

    if objective is None:
        raise SystemExit('Please select the objective function used in the optimization')

    if constraint is None:
        raise SystemExit('Please select the epsilon constraint used in the optimization')

    if EMOO_list==[]:
        raise SystemExit('Please enter the list of epsilon constraint used in the pathway optimization')

    if y_span==[]:
        raise SystemExit('Please enter the list of years used in the pathway optimization')

    ###################################
    ##### First plot: EMOO pathway ####
    ###################################

    # Initialize plot
    fig, ax1=plt.subplots(figsize=(12,7))

    # Set title
    title_str="Investment Pathway"
    if district is not None:
        title_str=title_str+" in district "+str(district)
    if scn_number is not None:
        title_str=title_str+" for scenario " + str(scn_number)
    ax1.set_title(title_str, fontsize=25)

    # Set x-axis parameters
    ax1.tick_params(axis='x', labelsize=15)

    # Retrieve and plot results
    obj=[]
    obj2=[]
    add_line=True
    if era is None:
        era = results[scn_id][0]['df_Buildings']['ERA'].sum()

    if objective=='CAPEX':
        obj_label = 'Cost [CHF/m$^2$/y]'
        for i in range(len(EMOO_list)):
            obj=obj+[results[scn_id][i]['df_KPIs']['capex_m2']['Network']]
            obj2 = obj2 + [results[scn_id][i]['df_KPIs']['opex_m2']['Network']]
        obj_old = objective
        objective = 'CAPEX' #'Cumulative CAPEX'
        lns4 = ax1.plot(y_span, obj2, label='OPEX', color='C0', linewidth=2, linestyle='--')
    elif objective=='TOTEX':
        obj_label = 'Cost [CHF/m$^2$/y]'
        for i in range(len(EMOO_list)):
            obj = obj + [results[scn_id][i]['df_KPIs']['capex_m2']['Network']]
            obj2= obj2 + [results[scn_id][i]['df_KPIs']['opex_m2']['Network']]
        obj_old = objective
        objective= 'CAPEX' #'Cumulative CAPEX'
        lns4 = ax1.plot(y_span, obj2, label='OPEX', color='C0', linewidth=2, linestyle='--')

    lns1 = ax1.plot(y_span, obj, label=objective, color='C0', linewidth=2) # if want cumulative: plot np.cumsum(obj)

    # Left y-axis params
    ax1.set_ylabel(obj_label, color='C0', fontsize=20)
    ax1.tick_params(axis='y', labelcolor='C0', labelsize=15)
    ax1.set_ylim(bottom=min(min(obj),min(obj2)))

    # Creat a second y-axis for EMOO values
    ax11 = ax1.twinx()

    # Retrieve data for second axis

    GWP_pw=[]
    for i in range(len(EMOO_list)):
        GWP_pw = GWP_pw + [results[scn_id][i]['df_KPIs']['gwp_tot_m2']['Network']]

    constr=[]
    if constraint=='GWP':
        constr_label='GWP [kgCO2/m$^2$yr]'
        constr=GWP_pw

    elif constraint == 'elec_export':
        constr_label='Energy net export [MWh/m$^2$y]'

        for i in range(len(EMOO_list)):
            df_an = results[scn_id][i]['df_Annuals'].loc['Electricity'].loc['Network']
            current_constr = (df_an['Demand_MWh'] - df_an['Supply_MWh']) / era
            constr = constr + [current_constr]
    elif constraint == 'EV':
        constr_label='Number of EV'
        constr=EV_yearly[[True if x in np.round(y_span) else False for x in y_span_yearly]]
        EMOO_list=constr



    # Plot data on the second y-axis
    lns2 = ax11.plot(y_span, constr, label=constraint, color='C1', linewidth=2)
    #lns3 = ax11.plot(y_span, EMOO_list, label='EMOO', color='C1', linestyle='--', linewidth=2)

    # right y-axis parameters
    ax11.set_ylabel(constr_label, color='C1',fontsize=20)
    ax11.tick_params(axis='y', labelcolor='C1', labelsize=15)
    ax11.set_ylim(bottom=min(min(constr),min(EMOO_list)))

    # Add legend

    #lns = lns1 + lns2 + lns3 + lns4
    lns = lns1 + lns2 + lns4
    labs = [l.get_label() for l in lns]
    ax1.legend(lns, labs, loc=5,fontsize=15)

    # specify xticks to be each year computed
    ax1.set_xticks(np.round(y_span))
    ax1.set_xlabel("Year",fontsize=20)

    # Fix background grid
    nticks = 6
    ax1.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))
    ax11.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))
    ax1.grid()

    # Show resulting figure
    fig.tight_layout()
    fig.show()

    # Save first figure
    if filename is not None:
        filename_set = os.path.join(save_path, filename + '_EMOO.'+export_format)
        fig.savefig(filename_set)


    ############################################
    ##### Second plot: Installed capacities ####
    ############################################



    # Specify color palettes
    colors_buildings=['#42a227','#8727a2','#a22742','#27a287','#2742a2','#a28727','#a24327','#85a227','#4327a2','#a22785']#,'#27a243','#2785a2']
    buildings_tech=['Air_Conditioner_Air', 'Battery', 'ElectricalHeater', 'HeatPump_Air','HeatPump_Geothermal','NG_Boiler', 'NG_Cogeneration', 'PV', 'ThermalSolar','WaterTank']#, 'TransformerReinforcement', 'LineReinforcement']
    color_buildings=pd.DataFrame({'Unit':buildings_tech,'color':colors_buildings}).set_index('Unit')

    colors_reinf=['#42a227','#a22742']
    reinf_tech=['TransformerReinforcement','LineReinforcement']
    color_reinforcement = pd.DataFrame({'Unit': reinf_tech, 'color': colors_reinf}).set_index('Unit')

    colors_district = ['#42a227', '#a22742','#8727a2','#27a287','#2742a2','#a28727']
    district_tech = ['Battery_district', 'EV_district', 'NG_Cogeneration_district','HeatPump_Geothermal_district','DHN_out_district','NG_Boiler_district']
    color_district = pd.DataFrame({'Unit': district_tech, 'color': colors_district}).set_index('Unit')


    # Retrieve results
    df = pd.DataFrame()
    df_reinforcement=pd.DataFrame()

    grouped=['WaterTank','ElectricalHeater']
    for i in range(0, len(EMOO_list)):
        start_df = pd.DataFrame(results[scn_id][i]['df_Unit']['Units_Mult'].reset_index().apply(
            lambda x: x['Unit'].split('_Building')[0], axis=1),columns=['Unit'])
        start_df=start_df.apply(lambda x: next((g for g in grouped if g in x['Unit']), x['Unit']), axis=1)
        start=start_df.squeeze()

        # start = reho.results[scn_id][i]['df_Unit'].query("Units_Use==1").reset_index().apply(lambda x: x['Unit'].split('_Building')[0], axis=1)
        if i==0:
            df_transformer=pd.DataFrame(data=[results[scn_id][0]['df_Grid'].loc['Network'].loc['Electricity']['Capacity']*results[scn_id][0]['df_Grid'].loc['Network'].loc['Electricity']['UseCapacity']],
                     columns=['Units_Mult'], index=['TransformerReinforcement'])
            df_line=pd.DataFrame(data=[(results[scn_id][0]['df_Grid'].drop(['Network']).drop(['NaturalGas'],level=1)['Capacity']*results[scn_id][0]['df_Grid'].drop(['Network']).drop(['NaturalGas'],level=1)['UseCapacity']).sum()],columns=['Units_Mult'],index=['LineReinforcement'])
        else:
            df_transformer = pd.DataFrame(
                data=[results[scn_id][i]['df_Grid'].loc['Network'].loc['Electricity']['Capacity'] -
                      results[scn_id][i-1]['df_Grid'].loc['Network'].loc['Electricity']['Capacity']],
                columns=['Units_Mult'], index=['TransformerReinforcement'])
            df_line = pd.DataFrame(data=[
                results[scn_id][i]['df_Grid'].drop(['Network']).drop(['NaturalGas'], level=1)['Capacity'].sum() -
                results[scn_id][i-1]['df_Grid'].drop(['Network']).drop(['NaturalGas'], level=1)['Capacity'].sum()],
                                   columns=['Units_Mult'], index=['LineReinforcement'])
        df = pd.concat([df, results[scn_id][i]['df_Unit']['Costs_Unit_inv'].reset_index().groupby(start).sum(
            'Costs_Unit_inv').rename(columns={'Costs_Unit_inv': int(y_span[i])})], axis=1)
        df_reinforcement=pd.concat([df_reinforcement,pd.concat([df_transformer,df_line]).rename(columns={'Units_Mult': int(y_span[i])})],axis=1)
    df_buildings=df[~(df.index.str.contains('district'))]/era*100
    df_district=df[df.index.str.contains('district')]/era*100
    df_district=round(df_district,2)

    average_network_power = results[scn_id][0]['df_Annuals'].xs('Electricity').loc['Network']['Supply_MWh'] * 1000 / (results[scn_id][0]['df_Time']['dp'].sum() * 24)
    df_reinforcement = df_reinforcement/average_network_power
        # df=pd.concat([df,reho.results[scn_id][0]['df_Unit'].query("Units_Use==1")['Units_Mult'].reset_index().groupby(start).sum('Units_Mult').rename(columns={'Units_Mult': str(y_span[i])})],axis=1)

    # Plot buildings

    # Initialize plot
    fig2, ax2 = plt.subplots(figsize=(max(len(EMOO_list)*1.8,10),9))
    df_buildings_to_plot1 = df_buildings[(df_buildings.transpose() != 0).any(axis=0)]
    Name_list_to_plot_buildings=['Air conditioner', 'Battery', 'Electrical heater', 'Heat pump Air','Heat pump Geothermal','Gas boiler','Gas cogeneration','PV','Thermal Solar','Water tank']
    df_buildings.index=Name_list_to_plot_buildings
    df_buildings_to_plot=df_buildings[(df_buildings.transpose() != 0).any(axis=0)]
    if df_buildings_to_plot.empty == False:
        color_buildings_to_plot=color_buildings.loc[list(df_buildings_to_plot1.index)]['color'].to_list()
        df_buildings_to_plot.transpose().plot(kind='bar', stacked=True,
                                                                  ylabel='Additional investment [CHF/y/100$m^2$]', xlabel='Year', grid=True,
                                                                  ax=ax2, width=0.6,color=color_buildings_to_plot)


    # Set axis parameters
    ax2.tick_params(axis='both', labelsize=20,rotation=0)
    ax2.set_xlabel(ax2.get_xlabel(), fontsize=22)
    ax2.set_ylabel(ax2.get_ylabel(), fontsize=22)
    # Specify legend and title
    ax2.legend(fontsize=18, loc='upper center', bbox_to_anchor=(0.5, -0.15),ncol=3)

    title_str="Buildings investment"
    if district is not None:
        title_str=title_str+" in district "+str(district)
    if scn_number is not None:
        title_str=title_str+"\n for scenario " + str(scn_number)
    ax2.set_title(title_str, fontsize=25)


    # Add cumulative GWP
    ax22 = ax2.twinx()
    ax22.plot(np.cumsum(GWP_pw),label='Cumulative GWP', color='C0',linewidth=2)
    ax22.set_ylabel("Cumulative GWP [kgCO2/m$^2$yr]", fontsize=22,color='C0')
    ax22.tick_params(axis='y', labelcolor='C0', labelsize=20)
    ax22.set_ylim(bottom=min(GWP_pw))

    # Fix background grid
    nticks = 6
    ax2.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))
    ax22.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))
    ax22.set_yticks(np.linspace(0, 200, 6))
    ax2.set_yticks(np.linspace(0, 4200, 6))
    ax22.grid()
    # Show resulting figure
    fig2.tight_layout()
    fig2.show()

    # Plot districts
    # Initialize plot
    fig3, ax3 = plt.subplots(figsize=(max(len(EMOO_list) * 1.8, 10), 9))
    df_district_to_plot1 = df_district[(df_district.transpose() != 0).any(axis=0)]
    Name_list_to_plot_district=['Battery','EV']
    df_district.index=Name_list_to_plot_district
    df_district_to_plot = df_district[(df_district.transpose() != 0).any(axis=0)]
    if df_district_to_plot.empty==False:
        color_district_to_plot = color_district.loc[list(df_district_to_plot1.index)]['color'].to_list()
        df_district_to_plot.transpose().plot(kind='bar', stacked=True,
                                          ylabel='Additional investment [CHF/y/100$m^2$]', xlabel='Year', grid=True,
                                          ax=ax3, width=0.6, color=color_district_to_plot)


    # Set axis parameters
    ax3.tick_params(axis='both', labelsize=20, rotation=0)
    ax3.set_xlabel(ax3.get_xlabel(), fontsize=22)
    ax3.set_ylabel(ax3.get_ylabel(), fontsize=22)
    # Specify legend and title
    ax3.legend(fontsize=18, loc='upper center', bbox_to_anchor=(0.5, -0.15), ncol=3)
    title_str="District investment"
    if district is not None:
        title_str=title_str+" in district "+str(district)
    if scn_number is not None:
        title_str=title_str+" for scenario " + str(scn_number)
    ax3.set_title(title_str, fontsize=25)
    # Show resulting figure
    fig3.tight_layout()
    fig3.show()

    # Plot reinforcement

    # Initialize plot
    fig4, ax4 = plt.subplots(figsize=(max(len(EMOO_list) * 1.8, 10), 9))
    df_reinforcement_to_plot1 = df_reinforcement[(df_reinforcement.transpose() != 0).any(axis=0)]
    Name_list_to_plot_reinforcement=['Transformer','Lines']
    df_reinforcement.index=Name_list_to_plot_reinforcement
    df_reinforcement_to_plot = df_reinforcement[(df_reinforcement.transpose() != 0).any(axis=0)]
    if df_reinforcement_to_plot.empty == False:
        color_reinforcement_to_plot = color_reinforcement.loc[list(df_reinforcement_to_plot1.index)]['color'].to_list()
        df_reinforcement_to_plot.transpose().plot(kind='bar', stacked=True,
                                         ylabel="Normalized Additional Reinforcement \n"+r"[kW/$\overline{kW}$]", xlabel='Year', grid=True,
                                         ax=ax4, width=0.6, color=color_reinforcement_to_plot)


    # Set axis parameters
    ax4.tick_params(axis='both', labelsize=20, rotation=0)
    ax4.set_xlabel(ax4.get_xlabel(), fontsize=22)
    ax4.set_ylabel(ax4.get_ylabel(), fontsize=24)
    # Specify legend and title
    ax4.legend(fontsize=18, loc='upper center', bbox_to_anchor=(0.5, -0.15), ncol=3)
    title_str="Grid reinforcement"
    if district is not None:
        title_str=title_str+" in district "+str(district)
    if scn_number is not None:
        title_str=title_str+" for scenario " + str(scn_number)
    ax4.set_title(title_str, fontsize=25)
    ax4.set_yticks(np.linspace(0, 300, 6))
    # Show resulting figure
    fig4.tight_layout()
    fig4.show()

    # Save figures
    if filename is not None:
        filename_set2 = os.path.join(save_path, filename + '_buildings.'+export_format)
        filename_set3 = os.path.join(save_path, filename + '_district.' + export_format)
        filename_set4 = os.path.join(save_path, filename + '_reinforcement.' + export_format)
        fig2.savefig(filename_set2)
        fig3.savefig(filename_set3)
        fig4.savefig(filename_set4)
    fig5=[]
    # Plot EV and battery pathway, if it exists
    if Battery_yearly!=[] and EV_yearly!=[] and y_span_yearly!=[]:
        fig5,ax5=plt.subplots(figsize=(12,7))

        # Set title
        title_str = "EV Pathway"
        if district is not None:
            title_str = title_str + " in district " + str(district)
        if scn_number is not None:
            title_str = title_str + " for scenario " + str(scn_number)
        ax5.set_title(title_str, fontsize=25)

        # Set x-axis parameters
        ax5.tick_params(axis='x', labelsize=20)

        # Fix background grid
        nticks = 6
        ax5.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))


        ax5.plot(y_span_yearly,EV_yearly,label='EV objective',color='C0')
        ax5.set_yticks(ax5.get_yticks(), np.arange(0, np.ceil(max(EV_yearly) / 6) * 6, np.ceil(max(EV_yearly) / 6)))
        # Left y-axis params
        ax5.set_ylabel('Number of EVs in the district', color='C0', fontsize=20)
        ax5.tick_params(axis='y', labelcolor='C0', labelsize=15)
        ax5.set_ylim(bottom=0)
        ax55 = ax5.twinx()
        ax55.plot(y_span_yearly, Battery_yearly, label='Additional batteries from EV', color='C1')
        # right y-axis parameters
        ax55.set_ylabel('Additional battery capacity [kWh]', color='C1', fontsize=20)
        ax55.tick_params(axis='y', labelcolor='C1', labelsize=15)
        ax55.set_ylim(bottom=0)

        # specify xticks to be each year computed
        ax5.set_xlabel("Year", fontsize=20)

        # Fix background grid
        nticks = 6
        ax5.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))
        ax5.set_yticks(ax5.get_yticks(), np.arange(0, np.ceil(max(EV_yearly) / 6) * 6, np.ceil(max(EV_yearly) / 6)))
        ax55.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))

        ax5.grid()

        # Show resulting figure
        fig5.tight_layout()
        fig5.show()
        if filename is not None:
            filename_set5 = os.path.join(save_path, filename + '_pathway_EV.' + export_format)
            fig5.savefig(filename_set5)


    return fig,fig2,fig3,fig4


def plot_pathway_FR(results, scn_id=None, EMOO_list=[], y_span=[], Battery_yearly=[], EV_yearly=[], y_span_yearly=[],
                 label='EN_short', save_path="", filename=None, export_format='html', objective=None, constraint=None,
                 district=None, scn_number=None):
    """
        Generate a line plot showing the investment pathway for the respective Objective function and EMOO selected

        :param results: Dictionary containing REHO results.
        :type results: dict

        :param label: Indicates the language to use for the plot. Pick among 'FR_long', 'FR_short', 'EN_long', 'EN_short'.
        :type label: str

        :param save_path: Path where the plot should be saved.
        :type save_path: str

        :param filename: Name of the file to be saved.
        :type filename: str

        :param export_format: Format for exporting the plot ('html' or 'png', default: 'html').
        :type export_format: str

        :return: The generated figure.
    """
    if scn_id is None:
        scn_id = list(results.keys())[0]

    if objective is None:
        raise SystemExit('Please select the objective function used in the optimization')

    if constraint is None:
        raise SystemExit('Please select the epsilon constraint used in the optimization')

    if EMOO_list == []:
        raise SystemExit('Please enter the list of epsilon constraint used in the pathway optimization')

    if y_span == []:
        raise SystemExit('Please enter the list of years used in the pathway optimization')


    ############################################
    ##### Second plot: Installed capacities ####
    ############################################

    # Specify color palettes
    colors_buildings = ['#42a227', '#8727a2', '#a22742', '#27a287', '#2742a2', '#a28727', '#a24327', '#85a227',
                        '#4327a2', '#a22785']  # ,'#27a243','#2785a2']
    buildings_tech = ['Air_Conditioner_Air', 'Battery', 'ElectricalHeater', 'HeatPump_Air', 'HeatPump_Geothermal',
                      'NG_Boiler', 'NG_Cogeneration', 'PV', 'ThermalSolar',
                      'WaterTank']  # , 'TransformerReinforcement', 'LineReinforcement']
    color_buildings = pd.DataFrame({'Unit': buildings_tech, 'color': colors_buildings}).set_index('Unit')

    colors_reinf = ['#42a227', '#a22742']
    reinf_tech = ['TransformerReinforcement', 'LineReinforcement']
    color_reinforcement = pd.DataFrame({'Unit': reinf_tech, 'color': colors_reinf}).set_index('Unit')

    colors_district = ['#42a227', '#a22742', '#8727a2', '#27a287', '#2742a2', '#a28727']
    district_tech = ['Battery_district', 'EV_district', 'NG_Cogeneration_district', 'HeatPump_Geothermal_district',
                     'DHN_out_district', 'NG_Boiler_district']
    color_district = pd.DataFrame({'Unit': district_tech, 'color': colors_district}).set_index('Unit')

    # Retrieve results
    df = pd.DataFrame()
    df_reinforcement = pd.DataFrame()

    grouped = ['WaterTank', 'ElectricalHeater']
    for i in range(0, len(EMOO_list)):
        start_df = pd.DataFrame(results['df_Unit'].loc[i]['Units_Mult'].reset_index().apply(
            lambda x: x['Unit'].split('_Building')[0], axis=1), columns=['Unit'])
        start_df = start_df.apply(lambda x: next((g for g in grouped if g in x['Unit']), x['Unit']), axis=1)
        start = start_df.squeeze()

        # start = reho.results[scn_id][i]['df_Unit'].query("Units_Use==1").reset_index().apply(lambda x: x['Unit'].split('_Building')[0], axis=1)
        if i == 0:
            df_transformer = pd.DataFrame(data=[
                results['df_Grid'].xs(0, level=0).xs('Network', level=0).loc['Electricity']['Capacity'] *
                results['df_Grid'].xs(0, level=0).xs('Network', level=0).loc['Electricity']['UseCapacity']],
                                          columns=['Units_Mult'], index=['TransformerReinforcement'])
            df_line = pd.DataFrame(data=[(results['df_Grid'].xs(0,level=0).drop(['Network'],level=0).drop(['NaturalGas'],level=1)['Capacity']*results['df_Grid'].xs(0,level=0).drop(['Network'],level=0).drop(['NaturalGas'],level=1)['UseCapacity']).sum()], columns=['Units_Mult'],
                                   index=['LineReinforcement'])
        else:
            df_transformer = pd.DataFrame(
                data=[results['df_Grid'].xs(i, level=0).xs('Network', level=0).loc['Electricity']['Capacity'] -
                      results['df_Grid'].xs(i-1, level=0).xs('Network', level=0).loc['Electricity']['Capacity']],
                columns=['Units_Mult'], index=['TransformerReinforcement'])
            df_line = pd.DataFrame(data=[
                (results['df_Grid'].xs(i,level=0).drop(['Network'],level=0).drop(['NaturalGas'],level=1)['Capacity']).sum() -
                (results['df_Grid'].xs(i-1,level=0).drop(['Network'],level=0).drop(['NaturalGas'],level=1)['Capacity']).sum()],
                columns=['Units_Mult'], index=['LineReinforcement'])
        df = pd.concat([df, results['df_Unit'].xs(i,level=0)['Costs_Unit_inv'].reset_index().groupby(start).sum('Costs_Unit_inv').rename(columns={'Costs_Unit_inv': int(y_span[i])})], axis=1)
        df_reinforcement = pd.concat(
            [df_reinforcement, pd.concat([df_transformer, df_line]).rename(columns={'Units_Mult': int(y_span[i])})],
            axis=1)
    df_buildings = df[~(df.index.str.contains('district'))]/1e6
    df_district = df[df.index.str.contains('district')]/1e6
    df_district = round(df_district, 2)

    average_network_power = results['df_Annuals'].xs(0,level=0).xs('Electricity',level=0).loc['Network']['Supply_MWh']*1000/8760
    df_reinforcement = df_reinforcement / average_network_power

    # df=pd.concat([df,reho.results[scn_id][0]['df_Unit'].query("Units_Use==1")['Units_Mult'].reset_index().groupby(start).sum('Units_Mult').rename(columns={'Units_Mult': str(y_span[i])})],axis=1)

    # Plot buildings

    # Initialize plot
    fig2, ax2 = plt.subplots(figsize=(max(len(EMOO_list) * 1.8, 10), 9))
    df_buildings_to_plot1 = df_buildings[(df_buildings.transpose() != 0).any(axis=0)]
    Name_list_to_plot_buildings = ['Air conditioner', 'Battery', 'Electrical heater', 'Heat pump Air',
                                   'Heat pump Geothermal', 'Gas boiler', 'Gas cogeneration', 'PV', 'Thermal Solar',
                                   'Water tank']
    df_buildings.index = Name_list_to_plot_buildings
    df_buildings_to_plot = df_buildings[(df_buildings.transpose() != 0).any(axis=0)]
    if df_buildings_to_plot.empty == False:
        color_buildings_to_plot = color_buildings.loc[list(df_buildings_to_plot1.index)]['color'].to_list()
        df_buildings_to_plot.transpose().plot(kind='bar', stacked=True,
                                              ylabel='Additional investment [MCHF/yr]', xlabel='Year', grid=True,
                                              ax=ax2, width=0.6, color=color_buildings_to_plot)

    # Set axis parameters
    ax2.tick_params(axis='both', labelsize=20, rotation=0)
    ax2.set_xlabel(ax2.get_xlabel(), fontsize=22)
    ax2.set_ylabel(ax2.get_ylabel(), fontsize=22)
    # Specify legend and title
    ax2.legend(fontsize=18, loc='upper center', bbox_to_anchor=(0.5, -0.15), ncol=3)

    title_str = "Buildings investment"
    if district is not None:
        title_str = title_str + " in district " + str(district)
    if scn_number is not None:
        title_str = title_str + "\n for scenario " + str(scn_number)
    ax2.set_title(title_str, fontsize=25)

    GWP_pw=[]
    for i in range(len(EMOO_list)):
        GWP_pw = GWP_pw + [results['df_KPIs'].xs(i,level=0)['gwp_tot_m2']['Network']]
    # Add cumulative GWP
    ax22 = ax2.twinx()
    ax22.plot(np.cumsum(GWP_pw), label='Cumulative GWP', color='C0', linewidth=2)
    ax22.set_ylabel("Cumulative GWP [kgCO2/m$^2$yr]", fontsize=22, color='C0')
    ax22.tick_params(axis='y', labelcolor='C0', labelsize=20)
    ax22.set_ylim(bottom=min(GWP_pw))

    # Fix background grid
    nticks = 6
    ax2.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))
    ax22.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))
    ax22.set_yticks(np.linspace(0, 200, 6))
    ax2.set_yticks(np.linspace(0, 60, 6))
    ax22.grid()
    # Show resulting figure
    fig2.tight_layout()
    fig2.show()

    # Plot districts
    # Initialize plot
    fig3, ax3 = plt.subplots(figsize=(max(len(EMOO_list) * 1.8, 10), 9))
    df_district_to_plot1 = df_district[(df_district.transpose() != 0).any(axis=0)]
    Name_list_to_plot_district = ['Battery', 'EV']
    df_district.index = Name_list_to_plot_district
    df_district_to_plot = df_district[(df_district.transpose() != 0).any(axis=0)]
    if df_district_to_plot.empty == False:
        color_district_to_plot = color_district.loc[list(df_district_to_plot1.index)]['color'].to_list()
        df_district_to_plot.transpose().plot(kind='bar', stacked=True,
                                             ylabel='Additional investment [MCHF/yr]', xlabel='Year', grid=True,
                                             ax=ax3, width=0.6, color=color_district_to_plot)

    # Set axis parameters
    ax3.tick_params(axis='both', labelsize=20, rotation=0)
    ax3.set_xlabel(ax3.get_xlabel(), fontsize=22)
    ax3.set_ylabel(ax3.get_ylabel(), fontsize=22)
    # Specify legend and title
    ax3.legend(fontsize=18, loc='upper center', bbox_to_anchor=(0.5, -0.15), ncol=3)
    title_str = "District investment"
    if district is not None:
        title_str = title_str + " in district " + str(district)
    if scn_number is not None:
        title_str = title_str + " for scenario " + str(scn_number)
    ax3.set_title(title_str, fontsize=25)
    # Show resulting figure
    fig3.tight_layout()
    fig3.show()

    # Plot reinforcement

    # Initialize plot
    fig4, ax4 = plt.subplots(figsize=(max(len(EMOO_list) * 1.8, 10), 9))
    df_reinforcement_to_plot1 = df_reinforcement[(df_reinforcement.transpose() != 0).any(axis=0)]
    Name_list_to_plot_reinforcement = ['Transformer', 'Lines']
    df_reinforcement.index = Name_list_to_plot_reinforcement
    df_reinforcement_to_plot = df_reinforcement[(df_reinforcement.transpose() != 0).any(axis=0)]
    if df_reinforcement_to_plot.empty == False:
        color_reinforcement_to_plot = color_reinforcement.loc[list(df_reinforcement_to_plot1.index)]['color'].to_list()
        df_reinforcement_to_plot.transpose().plot(kind='bar', stacked=True,
                                                  ylabel="Normalized Additional Reinforcement \n"+r"[kW/$\overline{kW}$]",
                                                  xlabel='Year', grid=True,
                                                  ax=ax4, width=0.6, color=color_reinforcement_to_plot)

    # Set axis parameters
    ax4.tick_params(axis='both', labelsize=20, rotation=0)
    ax4.set_xlabel(ax4.get_xlabel(), fontsize=22)
    ax4.set_ylabel(ax4.get_ylabel(), fontsize=24)
    ax4.set_yticks(np.linspace(0, 80, 6))
    # Specify legend and title
    ax4.legend(fontsize=18, loc='upper center', bbox_to_anchor=(0.5, -0.15), ncol=3)
    title_str = "Grid reinforcement"
    if district is not None:
        title_str = title_str + " in district " + str(district)
    if scn_number is not None:
        title_str = title_str + " for scenario " + str(scn_number)
    ax4.set_title(title_str, fontsize=25)
    ax4.set_yticks(np.linspace(0, 60, 6))
    # Show resulting figure
    fig4.tight_layout()
    fig4.show()

    # Save figures
    if filename is not None:
        filename_set2 = os.path.join(save_path, filename + '_buildings.' + export_format)
        filename_set3 = os.path.join(save_path, filename + '_district.' + export_format)
        filename_set4 = os.path.join(save_path, filename + '_reinforcement.' + export_format)
        fig2.savefig(filename_set2)
        fig3.savefig(filename_set3)
        fig4.savefig(filename_set4)
    fig5 = []
    # Plot EV and battery pathway, if it exists
    if Battery_yearly != [] and EV_yearly != [] and y_span_yearly != []:
        fig5, ax5 = plt.subplots(figsize=(12, 7))

        # Set title
        title_str = "EV Pathway"
        if district is not None:
            title_str = title_str + " in district " + str(district)
        if scn_number is not None:
            title_str = title_str + " for scenario " + str(scn_number)
        ax5.set_title(title_str, fontsize=25)

        # Set x-axis parameters
        ax5.tick_params(axis='x', labelsize=20)

        # Fix background grid
        nticks = 6
        ax5.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))

        ax5.plot(y_span_yearly, EV_yearly, label='EV objective', color='C0')
        ax5.set_yticks(ax5.get_yticks(), np.arange(0, np.ceil(max(EV_yearly) / 6) * 6, np.ceil(max(EV_yearly) / 6)))
        # Left y-axis params
        ax5.set_ylabel('Number of EVs in the district', color='C0', fontsize=20)
        ax5.tick_params(axis='y', labelcolor='C0', labelsize=15)
        ax5.set_ylim(bottom=0)
        ax55 = ax5.twinx()
        ax55.plot(y_span_yearly, Battery_yearly, label='Additional batteries from EV', color='C1')
        # right y-axis parameters
        ax55.set_ylabel('Additional battery capacity [kWh]', color='C1', fontsize=20)
        ax55.tick_params(axis='y', labelcolor='C1', labelsize=15)
        ax55.set_ylim(bottom=0)

        # specify xticks to be each year computed
        ax5.set_xlabel("Year", fontsize=20)

        # Fix background grid
        nticks = 6
        ax5.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))
        ax5.set_yticks(ax5.get_yticks(), np.arange(0, np.ceil(max(EV_yearly) / 6) * 6, np.ceil(max(EV_yearly) / 6)))
        ax55.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks))

        ax5.grid()

        # Show resulting figure
        fig5.tight_layout()
        fig5.show()
        if filename is not None:
            filename_set5 = os.path.join(save_path, filename + '_pathway_EV.' + export_format)
            fig5.savefig(filename_set5)

    return fig2, fig3, fig4